// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: WifiConfig.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

//
// ezWifiConfig - Wifi Configuraiton over BLE
// Copyright (c) 2018. Geoffrey Matrangola, electrazoom.com
//
//     This program is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, version 3 of the License.
//
//     This program is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with this program.  If not, see <https://www.gnu.org/licenses/>
//
//     This program is also available under a commercial license. If you wish
//     to redistribute this library and derivative work for commercial purposes
//     please see ProtoBLE.com to obtain a proprietary license that will fit
//     your needs.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Mode requested by the user or the current mode resulting change
enum OperationMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case setupWifi // = 0
  case startService // = 1
  case stopService // = 2
  case restartService // = 3
  case shutdown // = 4
  case reboot // = 5
  case disableSetupMode // = 6
  case enableSetupMode // = 7
  case factoryReset // = 8
  case executeCommand // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .setupWifi
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .setupWifi
    case 1: self = .startService
    case 2: self = .stopService
    case 3: self = .restartService
    case 4: self = .shutdown
    case 5: self = .reboot
    case 6: self = .disableSetupMode
    case 7: self = .enableSetupMode
    case 8: self = .factoryReset
    case 9: self = .executeCommand
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .setupWifi: return 0
    case .startService: return 1
    case .stopService: return 2
    case .restartService: return 3
    case .shutdown: return 4
    case .reboot: return 5
    case .disableSetupMode: return 6
    case .enableSetupMode: return 7
    case .factoryReset: return 8
    case .executeCommand: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Error or success returned when changing operating Mode
enum OpeartingModeError: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case success // = 0
  case wifiError // = 1
  case bluetoothError // = 2
  case systemError // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .success
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .wifiError
    case 2: self = .bluetoothError
    case 4: self = .systemError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .success: return 0
    case .wifiError: return 1
    case .bluetoothError: return 2
    case .systemError: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Represents an 802.11 Wifi Wireless Access Point
struct AccessPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// General 802.11 flags
  var isPrivate: Bool = false

  /// 802.11 Infrastructure identifiers
  var ssid: String = String()

  var frequency: UInt32 = 0

  /// AKA HwAddress
  var mac: String = String()

  /// in Kb/s
  var maxBitrate: UInt32 = 0

  /// percentage
  var strength: UInt32 = 0

  /// standard Unix time
  var timeLastSeen: Int64 = 0

  /// AP is the active connection providing wireless network communication to the system
  var active: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a group of APs with the same SSID (Network Name) forming a typical wireless network.
struct SsidNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ssid: String = String()

  var isPrivate: Bool = false

  var strength: Int32 = 0

  var aps: [AccessPoint] = []

  /// One of the APs in the network is the active connection
  var active: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Wifi network scan results reported in networks. activeNetwork and activeAccessPoint represent the current connection
/// to the network and the AP within that network.
struct Scan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networks: [SsidNetwork] {
    get {return _storage._networks}
    set {_uniqueStorage()._networks = newValue}
  }

  var activeNetwork: SsidNetwork {
    get {return _storage._activeNetwork ?? SsidNetwork()}
    set {_uniqueStorage()._activeNetwork = newValue}
  }
  /// Returns true if `activeNetwork` has been explicitly set.
  var hasActiveNetwork: Bool {return _storage._activeNetwork != nil}
  /// Clears the value of `activeNetwork`. Subsequent reads from it will return its default value.
  mutating func clearActiveNetwork() {_storage._activeNetwork = nil}

  var activeAccessPoint: AccessPoint {
    get {return _storage._activeAccessPoint ?? AccessPoint()}
    set {_uniqueStorage()._activeAccessPoint = newValue}
  }
  /// Returns true if `activeAccessPoint` has been explicitly set.
  var hasActiveAccessPoint: Bool {return _storage._activeAccessPoint != nil}
  /// Clears the value of `activeAccessPoint`. Subsequent reads from it will return its default value.
  mutating func clearActiveAccessPoint() {_storage._activeAccessPoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// No Parameters
struct ScanRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Join the strongest AP on the ssid network or the ap specified
struct JoinRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connection: OneOf_Connection? {
    get {return _storage._connection}
    set {_uniqueStorage()._connection = newValue}
  }

  var ssid: String {
    get {
      if case .ssid(let v)? = _storage._connection {return v}
      return String()
    }
    set {_uniqueStorage()._connection = .ssid(newValue)}
  }

  var ap: AccessPoint {
    get {
      if case .ap(let v)? = _storage._connection {return v}
      return AccessPoint()
    }
    set {_uniqueStorage()._connection = .ap(newValue)}
  }

  var psk: String {
    get {return _storage._psk}
    set {_uniqueStorage()._psk = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Connection: Equatable {
    case ssid(String)
    case ap(AccessPoint)

    static func ==(lhs: JoinRequest.OneOf_Connection, rhs: JoinRequest.OneOf_Connection) -> Bool {
      switch (lhs, rhs) {
      case (.ssid(let l), .ssid(let r)): return l == r
      case (.ap(let l), .ap(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// if isSuccessfual is fals, errorMessage will provide information regarding the error
struct JoinResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isSuccessful: Bool = false

  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// No parameters, disconnects from all connected APs
struct DisconnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// returns true if disconnection request was successful
struct DisconnectResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isSuccessful: Bool = false

  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// System can accept a token or username and password
struct AuthenticateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Indicate the authentication was accepted
struct AuthenticateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authenticated: Bool = false

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request changing the operation mode
struct OperationModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationMode: OperationMode = .setupWifi

  var command: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Indicates success or failure after Operation Mode change request
struct OperationModeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationMode: OperationMode = .setupWifi

  var command: String = String()

  var error: OpeartingModeError = .success

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension OperationMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SETUP_WIFI"),
    1: .same(proto: "START_SERVICE"),
    2: .same(proto: "STOP_SERVICE"),
    3: .same(proto: "RESTART_SERVICE"),
    4: .same(proto: "SHUTDOWN"),
    5: .same(proto: "REBOOT"),
    6: .same(proto: "DISABLE_SETUP_MODE"),
    7: .same(proto: "ENABLE_SETUP_MODE"),
    8: .same(proto: "FACTORY_RESET"),
    9: .same(proto: "EXECUTE_COMMAND"),
  ]
}

extension OpeartingModeError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "WIFI_ERROR"),
    2: .same(proto: "BLUETOOTH_ERROR"),
    4: .same(proto: "SYSTEM_ERROR"),
  ]
}

extension AccessPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccessPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isPrivate"),
    200: .same(proto: "ssid"),
    201: .same(proto: "frequency"),
    202: .same(proto: "mac"),
    203: .same(proto: "maxBitrate"),
    204: .same(proto: "strength"),
    205: .same(proto: "timeLastSeen"),
    300: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isPrivate)
      case 200: try decoder.decodeSingularStringField(value: &self.ssid)
      case 201: try decoder.decodeSingularUInt32Field(value: &self.frequency)
      case 202: try decoder.decodeSingularStringField(value: &self.mac)
      case 203: try decoder.decodeSingularUInt32Field(value: &self.maxBitrate)
      case 204: try decoder.decodeSingularUInt32Field(value: &self.strength)
      case 205: try decoder.decodeSingularInt64Field(value: &self.timeLastSeen)
      case 300: try decoder.decodeSingularBoolField(value: &self.active)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isPrivate != false {
      try visitor.visitSingularBoolField(value: self.isPrivate, fieldNumber: 1)
    }
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 200)
    }
    if self.frequency != 0 {
      try visitor.visitSingularUInt32Field(value: self.frequency, fieldNumber: 201)
    }
    if !self.mac.isEmpty {
      try visitor.visitSingularStringField(value: self.mac, fieldNumber: 202)
    }
    if self.maxBitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBitrate, fieldNumber: 203)
    }
    if self.strength != 0 {
      try visitor.visitSingularUInt32Field(value: self.strength, fieldNumber: 204)
    }
    if self.timeLastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLastSeen, fieldNumber: 205)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 300)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: AccessPoint) -> Bool {
    if self.isPrivate != other.isPrivate {return false}
    if self.ssid != other.ssid {return false}
    if self.frequency != other.frequency {return false}
    if self.mac != other.mac {return false}
    if self.maxBitrate != other.maxBitrate {return false}
    if self.strength != other.strength {return false}
    if self.timeLastSeen != other.timeLastSeen {return false}
    if self.active != other.active {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension SsidNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SsidNetwork"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "isPrivate"),
    3: .same(proto: "strength"),
    4: .same(proto: "aps"),
    300: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ssid)
      case 2: try decoder.decodeSingularBoolField(value: &self.isPrivate)
      case 3: try decoder.decodeSingularInt32Field(value: &self.strength)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.aps)
      case 300: try decoder.decodeSingularBoolField(value: &self.active)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 1)
    }
    if self.isPrivate != false {
      try visitor.visitSingularBoolField(value: self.isPrivate, fieldNumber: 2)
    }
    if self.strength != 0 {
      try visitor.visitSingularInt32Field(value: self.strength, fieldNumber: 3)
    }
    if !self.aps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aps, fieldNumber: 4)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 300)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: SsidNetwork) -> Bool {
    if self.ssid != other.ssid {return false}
    if self.isPrivate != other.isPrivate {return false}
    if self.strength != other.strength {return false}
    if self.aps != other.aps {return false}
    if self.active != other.active {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Scan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Scan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "networks"),
    2: .same(proto: "activeNetwork"),
    3: .same(proto: "activeAccessPoint"),
  ]

  fileprivate class _StorageClass {
    var _networks: [SsidNetwork] = []
    var _activeNetwork: SsidNetwork? = nil
    var _activeAccessPoint: AccessPoint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _networks = source._networks
      _activeNetwork = source._activeNetwork
      _activeAccessPoint = source._activeAccessPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._networks)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._activeNetwork)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._activeAccessPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._networks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._networks, fieldNumber: 1)
      }
      if let v = _storage._activeNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._activeAccessPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Scan) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._networks != other_storage._networks {return false}
        if _storage._activeNetwork != other_storage._activeNetwork {return false}
        if _storage._activeAccessPoint != other_storage._activeAccessPoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ScanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ScanRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ScanRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension JoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "JoinRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "ap"),
    3: .same(proto: "psk"),
  ]

  fileprivate class _StorageClass {
    var _connection: JoinRequest.OneOf_Connection?
    var _psk: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connection = source._connection
      _psk = source._psk
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._connection != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._connection = .ssid(v)}
        case 2:
          var v: AccessPoint?
          if let current = _storage._connection {
            try decoder.handleConflictingOneOf()
            if case .ap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._connection = .ap(v)}
        case 3: try decoder.decodeSingularStringField(value: &_storage._psk)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._connection {
      case .ssid(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .ap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
      if !_storage._psk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._psk, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: JoinRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._connection != other_storage._connection {return false}
        if _storage._psk != other_storage._psk {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension JoinResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "JoinResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isSuccessful"),
    2: .same(proto: "errorMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isSuccessful)
      case 2: try decoder.decodeSingularStringField(value: &self.errorMessage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSuccessful != false {
      try visitor.visitSingularBoolField(value: self.isSuccessful, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: JoinResult) -> Bool {
    if self.isSuccessful != other.isSuccessful {return false}
    if self.errorMessage != other.errorMessage {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: DisconnectRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension DisconnectResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DisconnectResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isSuccessful"),
    2: .same(proto: "errorMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isSuccessful)
      case 2: try decoder.decodeSingularStringField(value: &self.errorMessage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSuccessful != false {
      try visitor.visitSingularBoolField(value: self.isSuccessful, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: DisconnectResult) -> Bool {
    if self.isSuccessful != other.isSuccessful {return false}
    if self.errorMessage != other.errorMessage {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AuthenticateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthenticateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.username)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      case 3: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: AuthenticateRequest) -> Bool {
    if self.username != other.username {return false}
    if self.password != other.password {return false}
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AuthenticateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthenticateResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticated"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.authenticated)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.authenticated != false {
      try visitor.visitSingularBoolField(value: self.authenticated, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: AuthenticateResult) -> Bool {
    if self.authenticated != other.authenticated {return false}
    if self.message != other.message {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension OperationModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OperationModeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationMode"),
    2: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.operationMode)
      case 2: try decoder.decodeSingularStringField(value: &self.command)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operationMode != .setupWifi {
      try visitor.visitSingularEnumField(value: self.operationMode, fieldNumber: 1)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: OperationModeRequest) -> Bool {
    if self.operationMode != other.operationMode {return false}
    if self.command != other.command {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension OperationModeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OperationModeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationMode"),
    2: .same(proto: "command"),
    3: .same(proto: "error"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.operationMode)
      case 2: try decoder.decodeSingularStringField(value: &self.command)
      case 3: try decoder.decodeSingularEnumField(value: &self.error)
      case 4: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operationMode != .setupWifi {
      try visitor.visitSingularEnumField(value: self.operationMode, fieldNumber: 1)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    if self.error != .success {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: OperationModeResult) -> Bool {
    if self.operationMode != other.operationMode {return false}
    if self.command != other.command {return false}
    if self.error != other.error {return false}
    if self.message != other.message {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
